# Week02（周三）

### 作业1.各垃圾收集器对比

<center>表1. 堆内存1GB 测试时间1s</center>

|    GC    | AVG（5 times） |
| :------: | :------------: |
|  Serial  |     15918      |
| Parallel |     19779      |
|   CMS    |     17816      |
|    G1    |     13497      |



### 作业2. 压测网关

<center>表2. 堆内存1GB 2线程 40连接 30s</center>

| 序号 | RPS      |
| ---- | -------- |
| 1    | 16677.70 |
| 2    | 20290.19 |
| 3    | 20372.43 |
| 4    | 20207.53 |
| 5    | 17289.58 |
| 6    | 20283.65 |
| 7    | 20527.62 |
| 8    | 21458.49 |
| 9    | 21013.01 |
| 10   | 20476.61 |
| AVG  | 19859.68 |



### 作业4. 总结

1. 垃圾收集器对比：从测试结果来看 G1< 串行GC < 并行GC ~ CMS 

   Parallelde 多线程垃圾回收的效率是显著提高的毫无疑问，CMS的性能比Parallel低，一开始我也觉得有点意外，在重新复习了一下《深入理解Java虚拟机》后，我又确定了CMS的优点：**为获取最短的停顿时间**，而Parallel Scavenge旨在达到最大的吞吐量，更高效地利用CPU。

   乍一看上去吞吐量高了，停顿时间不久自然低了吗？仔细想想其实不然，`吞吐量 = 用户线程CPU时间/（用户线程CPU时间 + GC线程CPU时间）`，CMS的获取最短停顿时间并不是指总的停顿时间，而是单次的停顿时间，或者换句话说，对用户线程的影响最小，“用户体验”更优。

   G1最为Java官方主推的新世代垃圾回收器在测试中结果反而最“拉跨”，“G1适合大内存使用”这句话怎么来的，我在这里试着简单分析一下。从G1的region机制来看，G1把堆内存分成n个大小相同的Region，每个Region可以根据需要扮演成新生代和老年代。那么我们是不是可以推断，当堆内存不够大时，每个region会更小，GC时对象（region）整理移动会更加频繁(也有资料说内存小导致没有足够Region可用，引发单线程Full GC)，加之G1本身更加耗费资源导致了它在小内存下表现不佳。

   > 当堆内存太小，G1在复制存活对象的时候发现没有空的内存分段可用，则会回退到Full GC，这就得加内存解决了。
   >
   > 另外，当并发处理过程完成前，内存空间就已经耗尽，也会触发Full GC。

   > “G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。”

   > G1的“大内存”阈值在6~8GB（堆内存），G1的定位是服务端的全功能垃圾收集器，旨在保证低延迟下获取最大的吞吐量。

   > G1最大的优点就是“暂停时间可预测”

